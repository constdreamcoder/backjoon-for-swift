//
//  15649.swift
//  BackJoonCodingPrac
//
//  Created by SUCHAN CHANG on 10/30/24.
//

import Foundation
/**
 풀이 아이디어 사고 과정
 1) 문제 분석
 - **모든 경우의 수**를 구해야 한다는 점에서 완전 탐색(모든 가능한 조합을 탐색)이 필요합니다.
 - 선택한 숫자들은** 중복되면 안 되며**, 특정 길이(M)를 만족해야 합니다.
 2) 완전 탐색(Brute-force) 접근 고려
 - 모든 가능한 조합을 구하려면 완전 탐색을 생각해 볼 수 있지만
 -  단순한 완전 탐색을 사용하면, 선택한 숫자가 중복되는 경우도 포함되거나, M개보다 많은 숫자를 선택하게 되는 비효율적인 경우가 발생할 수 있습니다.
 3) 백트래킹을 적용하기로 결정
 - **조건에 맞지 않는 경우 탐색을 조기에 중단할 수 있기 때문**입니다. 예를 들어, 이미 선택한 숫자와 중복된 숫자가 나오면 해당 경로를 더 이상 탐색하지 않고 되돌아가면 됩니다.
 - **해가 조건을 만족하면 결과를 출력하고 탐색을 종료**한 뒤 다른 경우의 수를 찾으면 됩니다.
 4) DFS와 백트래킹의 결합으로 풀이 방향 설정
 - DFS(깊이 우선 탐색)를 사용하여 첫 번째 숫자부터 M번째 숫자까지 탐색하는 방식으로 구현할 수 있습니다. DFS는 각 단계마다 깊이를 하나씩 늘려가며 탐색을 진행하는데, 여기서 백트래킹을 적용하여 조건에 맞지 않으면 더 깊이 탐색하지 않고 이전 단계로 돌아가 다른 선택을 하도록 만듭니다.
 
 사고과정 요약
 - 완전 탐색이 필요하다는 것을 문제에서 파악.
 - 중복을 피하고 특정 길이 조건을 만족해야 한다는 점에서 단순 완전 탐색보다 백트래킹이 적합하다고 판단.
 - DFS를 사용하여 각 수를 하나씩 선택해가며 탐색하고, 백트래킹으로 조건을 만족하지 않는 경우 탐색을 중단하도록 구현.

 성능 분석
 1. 시간복잡도
 - O(N!) (혹은 정확히는 𝑃 ( 𝑁 , 𝑀 ) P(N,M)), 최악의 경우 𝑁 = 8 N=8에서 40,320번의 연산.

 2. 공간복잡도
 - O(M+N)
 
 3. 효율성 향상 요소
 - 백트래킹을 통해 조건을 만족하지 않는 경우 조기에 탐색을 종료하여 불필요한 탐색을 줄임.
 */

// 입력을 받습니다.
let input = readLine()!.split(separator: " ").compactMap { Int($0) }
let n = input[0]  // 1부터 n까지의 숫자를 사용할 수 있습니다.
let m = input[1]  // 길이가 m인 수열을 만듭니다.

var sequence = [Int]()       // 현재 선택된 수열을 저장할 배열
var visited = Array(repeating: false, count: n + 1)  // 방문 여부를 체크할 배열

// 깊이 우선 탐색 함수
func dfs(depth: Int) {
    // 수열의 길이가 m이면 결과를 출력하고 종료
    if depth == m {
        print(sequence.map { String($0) }.joined(separator: " "))
        return
    }
    
    // 1부터 n까지의 숫자를 확인하면서 수열을 만듦
    for i in 1...n {
        // 방문하지 않은 숫자라면 수열에 추가
        if !visited[i] {
            visited[i] = true
            sequence.append(i)
            
            dfs(depth: depth + 1)  // 재귀 호출로 다음 숫자를 선택
            
            // 탐색 후 복귀하면서 선택한 숫자와 방문 표시를 취소
            sequence.removeLast()
            visited[i] = false
        }
    }
}

// DFS 탐색을 시작합니다.
dfs(depth: 0)

