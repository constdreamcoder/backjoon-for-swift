//
//  11403.swift
//  BackJoonCodingPrac
//
//  Created by SUCHAN CHANG on 12/21/24.
//

import Foundation

/**
 설명 - 그래프 탐색(`플로이드-워셜 알고리즘`)
 1. 그래프를 인접 행렬로 생성
 2. 플로이드-워셜 알고리즘 수행
    - 모든 노드에 대해 중간 노드(`k`)를 거쳐 가는 경로를 탐색하며, 경로가 존재하면 갱신
 3. 모든 노드 간의 연결 여부를 출력
 팁) 플로이드-워셜은 모든 노드 간 경로를 구할 때 적합하며, 음의 가중치가 없는 그래프에서 효과적임
 
 성능 분석
 1. 시간복잡도
 - 그래프 초기화: 입력으로 주어진 인접 행렬을 생성하는 데 \(O(N^2)\)의 시간 복잡도가 소요됩니다. 여기서 \(N\)은 노드의 개수입니다.
 - 플로이드-워셜 수행: 모든 노드 쌍에 대해 세 중첩 반복문(\(k, i, j\))을 실행하며, 각 반복문은 \(O(N)\)의 시간이 소요되므로 전체 시간 복잡도는 \(O(N^3)\)입니다.
 - 총 시간복잡도: ** O(N^3) **
 
 2. 공간복잡도
 - 그래프 인접 행렬: \(N \times N\) 크기의 2차원 배열을 사용하여 연결 상태를 저장하므로 \(O(N^2)\)의 공간이 필요합니다.
 - 추가 변수: 중간 노드(\(k\))와 반복문에서 사용하는 임시 변수들이 존재하지만, 이는 \(O(1)\)의 공간만 차지합니다.
 - 총 공간복잡도: ** O(N^2) **
 
 플로이드-워셜의 핵심 개념
 A 노드에서 B 노드까지 최단 경로를 구했다고 가정했을 때 최단 경로 위에 K 노드가 존재한다면 그것을 이루는 부분 경로 역시 최단 경로이다.
 <참조> https://www.youtube.com/watch?v=ibYzw9XAzyc
 
 플로이드-워셜 풀이법
 i 지점에서 j 지점까지 가는 도중 거쳐가는 노드 k에 대해 최적의 경로를 찾기 위해 모두 경로 탐색
 */

// 입력 처리
let n = Int(readLine()!)! // 정점의 개수
var graph = [[Int]]()

for _ in 0..<n {
    graph.append(readLine()!.split(separator: " ").map { Int($0)! })
}

// 플로이드-워셜 알고리즘
for k in 0..<n {           // 거쳐가는 노드
    for i in 0..<n {       // 출발 노드
        for j in 0..<n {   // 도착 노드
            // 노드 i → k와 k → j가 연결되어 있다면, 노드 i → j도 연결됨을 의미
            if graph[i][k] == 1 && graph[k][j] == 1 {
                graph[i][j] = 1
            }
        }
    }
}

// 결과 출력
for row in graph {
    print(row.map { String($0) }.joined(separator: " "))
}
