//
//  3986.swift
//  BackJoonCodingPrac
//
//  Created by SUCHAN CHANG on 11/19/24.
//

import Foundation

/**
설명 - 스택
1. 문자열을 하나씩 읽고 스택을 이용해 "좋은 단어"인지 검사합니다.
2. 문자를 순서대로 확인하면서, 스택이 비어있거나 최상단 문자와 현재 문자가 다르면 스택에 추가합니다. 만약 최상단 문자와 현재 문자가 같으면 스택에서 제거합니다.
3. 문자열 순회를 마친 후, 스택이 비어 있다면 해당 문자열은 "좋은 단어"로 판단합니다.
4. 모든 문자열을 검사한 후, "좋은 단어"의 개수를 출력합니다.

성능 분석
1. 시간복잡도
- 입력받는 문자열의 길이를 𝑛이라 하면, 각 문자열에 대해 내부 for 루프가 𝑂(𝑛)입니다.
- stack.append()와 stack.removeLast()의 연산은 모두 평균적으로 𝑂(1)입니다. 따라서 각 문자열을 검사하는 데는 𝑂(𝑛)이 소요됩니다.
- 전체 반복문은 테스트 케이스의 수 𝑇만큼 반복되므로, **총 시간 복잡도는 𝑂(𝑇 × 𝑛)**입니다.

2. 공간복잡도
- 스택에 최대 𝑛개의 문자를 저장할 수 있으므로, 각 테스트 케이스의 공간 복잡도는 **𝑂(𝑛)**입니다.
- 테스트 케이스 수 𝑇에 따라 여러 번 반복할 수 있지만, 메모리 사용량은 입력 크기에 비례하여 증가하지 않습니다.
*/

/**
 자료구조 선택 과정
 - 이 문제는 **"최근에 처리한 문자와 새로 처리할 문자를 비교"**하는 작업이 필요합니다.
 - 따라서 다음과 같은 조건을 만족하는 자료구조가 필요합니다:
    1. 최근에 추가된 문자를 빠르게 확인하고 제거해야 한다.
    2. 문자를 순차적으로 처리하며 중간 상태를 관리해야 한다.
 스택의 특징:
 - 스택은 LIFO(Last-In, First-Out) 구조로, "최근에 추가된 문자"를 관리하기에 최적화된 자료구조입니다.
 - push: 문자를 스택에 추가 (새로운 문자 처리).
 - pop: 최근 문자 제거 (짝지어진 문자 제거).
 이 특성은 문제에서 요구하는 "문자 짝 제거" 작업에 완벽히 부합합니다.
 
 결론적으로 스택을 이용하면:
 1. 최근 문자 상태 추적이 효율적이다.
 2. 문자를 짝지어 제거하는 작업이 자연스럽게 이루어진다.
 */

let n = Int(readLine()!)!
var goodWordCount = 0

for _ in 0..<n {
    let word = readLine()!
    var stack = [Character]()
    
    // 스택을 사용하여 문자 검사
    for char in word {
        if let last = stack.last, last == char {
            stack.removeLast() // 짝지어진 문자를 제거
        } else {
            stack.append(char) // 스택에 추가
        }
    }
    
    // 스택이 비어 있으면 좋은 단어
    if stack.isEmpty {
        goodWordCount += 1
    }
}

print(goodWordCount)
